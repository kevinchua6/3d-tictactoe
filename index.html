<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>3D Tic Tac Toe</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
		//Note, change canvas size to not scroll
		//Note, add the rotating camera with the mouse later, do the highlighting first
		
		// rendering var
		let container;
		let camera;
		let renderer;
		let scene;

		//The tic-tac-toe object vars
		let groupCubes;
		let cubes = [];
		let speed = 0.03;
		let isLeftKeyDown;
		let isRightKeyDown;
		let isUpKeyDown;
		let isDownKeyDown;

		//vars to interact with the tictactoe
		let mouse = new THREE.Vector2();
		let raycaster = new THREE.Raycaster();
		let closestIntersected;
		let intersects;
		let wheelNumber = 0;
		
		//ai
		var computerSelection;

		//Set everything up
		init()
		//Animate it
		animate();

		function init() {
			// Get a reference to the container that will hold our scene (this will be the entire window)
			container = document.body

			//create a scene
			scene = new THREE.Scene();

			//Set the background color
			scene.background = new THREE.Color('skyblue');

			// Create a Camera
			const fov = 35; // AKA Field of View
			const aspect = window.innerWidth / window.innerHeight;
			const near = 0.1; // the near clipping plane
			const far = 100; // the far clipping plane

			camera = new THREE.PerspectiveCamera( fov, aspect, near, far );

			camera.position.set( 0, 0, 7 );
			
			//Create a WebGLRenderer and set its width and height
			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight);
			// For mobile to be clearer
			renderer.setPixelRatio (window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			//Creates a groupCubes of cubes (the tic tac toe thing essentially)
			groupCubes = new THREE.Group();
			scene.add(groupCubes);

			//Creates 27 cubes
			for (var i=-1; i<=1; i++){
				for (var j=-1; j<=1; j++){
					for (var k=-1; k<=1; k++){
						cubes.push(createCubeWithWireframe(2/3,i*2/3,j*2/3,k*2/3));
					}
				}
			}

			for (cube of cubes){
				groupCubes.add(cube);
			}
			

			//Create a directional light
			const light = new THREE.DirectionalLight( 0xffffff, 5.0 );

			//Move the light back and up a bit
			light.position.set( 10, 10, 10);

			//Add light to scene
			scene.add( light );
			
			function createCubeWithWireframe(length, posx, posy, posz){
				//create a geometry
				const geometry = new THREE.BoxBufferGeometry( length, length, length );
				//create a basic material thats white
				const material = new THREE.MeshStandardMaterial( { 
					color: 0xffffff, 
					transparent: true,
					opacity: 0.5, 
					polygonOffset: true,
					polygonOffsetFactor: 1, // positive value pushes polygon further away
					polygonOffsetUnits: 1
				} );
				//create a mesh containing geometry and material
				const cube = new THREE.Mesh( geometry, material );
				cube.position.x = posx;
				cube.position.y = posy;
				cube.position.z = posz;
				scene.add( cube );

				//Add the wireframe
				const geometryWR = new THREE.EdgesGeometry( geometry);
				const materialWR = new THREE.LineBasicMaterial( { color: 0x000000 } ); //black
				const wireframe = new THREE.LineSegments( geometryWR, materialWR );
				cube.add(wireframe)

				// wireframe.position.x = posx;
				// wireframe.position.y = posy;
				// wireframe.position.z = posz;

				return (cube);
			}

			document.addEventListener('mousemove', onDocumentMouseMove, false)

			document.addEventListener("keydown", function(event) {
				event.preventDefault();
				const key = event.key; // "ArrowRight", "ArrowLeft", "ArrowUp", or "ArrowDown"
				
				switch (key) { // change to event.key to key to use the above variable
					case "a":
					case "ArrowLeft":{ 
						// Left pressed
						isLeftKeyDown = true;
						break;
					}
					case "d":
					case "ArrowRight": {
						// Right pressed
						isRightKeyDown = true;
						break;
					}
					case "w":
					case "ArrowUp": {
						// Up pressed
						isUpKeyDown = true;
						break;
					}
					case "s":
					case "ArrowDown": {
						// Down pressed
						isDownKeyDown = true;
						break;
					}
				}
			});

			document.addEventListener("keyup", function(event) {
				event.preventDefault();
				const key = event.key; // "ArrowRight", "ArrowLeft", "ArrowUp", or "ArrowDown"
				
				switch (key) { // change to event.key to key to use the above variable
					case "a":
					case "ArrowLeft":{ 
						// Left pressed
						isLeftKeyDown = false;
						break;
					}
					case "d":
					case "ArrowRight": {
						// Right pressed
						isRightKeyDown = false;
						break;
					}
					case "w":
					case "ArrowUp": {
						// Up pressed
						isUpKeyDown = false;
						break;
					}
					case "s":
					case "ArrowDown": {
						// Down pressed
						isDownKeyDown = false;
						break;
					}
				}
			});
		}

		function animate() {
			requestAnimationFrame( animate );
			renderer.render( scene, camera );
			handleKeys();
		};


		function onDocumentMouseMove(event) {
			//Calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			update()
		}

		function update(){
			//Update the picking ray with the camera and mouse position
			raycaster.setFromCamera( mouse, camera );

			//Calculate objects intersecting the picking ray
			intersects = raycaster.intersectObjects( groupCubes.children );
			//If one or more intersections,
			if ( intersects.length > 0 ) {
				
					//	closestIntersected = intersects[0];
					//If closest object intersected is not the currently stored intersection object
					//if (intersects[0].object != closestIntersected){
						//console.log(intersects);
						//Restore previous intersection obejct to its original color
						if (closestIntersected && !closestIntersected.selected)
							closestIntersected.material.color.setHex(0xffffff);
						//Store reference to the closest obj as intersection obj
						closestIntersected = intersects[0].object;

						if (!closestIntersected.selected){
						//Store current color of closest intersection obj
						closestIntersected.currentHex = closestIntersected.material.color.getHex();
						//Make the closest object red						
						intersects[0].object.material.color.set(0xff0000);
					}
				
			}
			else {
				if (closestIntersected && !closestIntersected.selected)
					closestIntersected.material.color.setHex(0xffffff);
				//Remove previous reference
				closestIntersected = null;
				
			}
		}

		window.addEventListener("wheel", event => {
			const delta = Math.sign(event.deltaY);
			//console.info(delta);
			if ( intersects.length > 1 ){
				//If scrolling up
				if (delta == -1){
					//eg if intersects.length = 2, wheelNumber would only go up to 1
					if (wheelNumber < intersects.length - 1 && !closestIntersected.selected) {
						wheelNumber += 1;
						intersects[wheelNumber].object.material.color.set(0xff0000);
						//Set current selected red back to its normal color and remove the previous reference
						if (closestIntersected && !closestIntersected.selected)
							closestIntersected.material.color.setHex(0xffffff);
						//Store currently selected to closestIntersected 
						closestIntersected = intersects[wheelNumber].object;
					}
					else if (wheelNumber == intersects.length - 1 && !closestIntersected.selected){
						wheelNumber = 0;
						intersects[wheelNumber].object.material.color.set(0xff0000);
						//Set current selected red back to its normal color and remove the previous reference
						if (closestIntersected && !closestIntersected.selected)
							closestIntersected.material.color.setHex(0xffffff);
						closestIntersected = intersects[wheelNumber].object;
					}
				}
				//If scrolling down
				else if (delta == 1){
					if (wheelNumber > 0 && !closestIntersected.selected){
						wheelNumber -=1;
						intersects[wheelNumber].object.material.color.set(0xff0000);
						//Set current selected red back to its normal color and remove the previous reference
						if (closestIntersected && !closestIntersected.selected)
							closestIntersected.material.color.setHex(0xffffff);
						closestIntersected = intersects[wheelNumber].object;
					}
					else if (wheelNumber == 0 && !closestIntersected.selected) {
						wheelNumber = intersects.length -1;
						intersects[wheelNumber].object.material.color.set(0xff0000);
						//Set current selected red back to its normal color and remove the previous reference
						if (closestIntersected && !closestIntersected.selected)
							closestIntersected.material.color.setHex(0xffffff);
						closestIntersected = intersects[wheelNumber].object;
					}
				}
			}
		});

		window.addEventListener("click", event => {
			if (closestIntersected && !closestIntersected.selected){
				closestIntersected.selected = true;
				//When click, the closestIntersected turns red and does not turn back even when hovered over.
				//That means that a variable for each object is required to show whether it can turn back to its normal color or not
				//ie, closestintersected.selected

				//Get a list of all available squares ie all the squares that do not have groupCubes.children[6].selected
				let squaresAvailableArray = [];
				for (var i=0; i<27; i++){
					if (!groupCubes.children[i].selected){
						squaresAvailableArray.push(groupCubes.children[i]);
					}
				}
				if (squaresAvailableArray.length > 0){
					let computerSelectionInt = randomInteger(0, squaresAvailableArray.length - 1 );
					computerSelection = squaresAvailableArray[computerSelectionInt];
					computerSelection.material.color.set(0x00ff00);
					computerSelection.selected = true;
				}
			}
		});

		function randomInteger(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		// function comMove(){
		// 	let computerSelectionInt = randomInteger(0, squaresAvailableArray.length);
		// 	computerSelection = groupCubes.children[computerSelectionInt];
		// 	computerSelection.material.color.set(0x00ff00);
		// 	computerSelection.selected = true;
		// }

		function handleKeys() {
			if (isLeftKeyDown == true) {
				//Iterates through all the values of cubes dict
				groupCubes.rotation.y -= speed;
			}
			if (isRightKeyDown == true) {
				groupCubes.rotation.y += speed;
				
			}
			if (isUpKeyDown == true) {
				groupCubes.rotation.x -= speed;
				
			}
			if (isDownKeyDown == true) {
				groupCubes.rotation.x += speed;
				
			}
		};

		</script>
	</body>
</html>